#!/bin/bash

##
## Copyright (c) 2024 Numurus, LLC <https://www.numurus.com>.
##
## This file is part of nepi-engine
## (see https://github.com/nepi-engine).
##
## License: 3-clause BSD, see https://opensource.org/licenses/BSD-3-Clause
##


# This file contains nepi bash utility functions

#echo "########################"
#echo "STARTING NEPI Bash Utils"
#echo "########################"


utilsn=""


###################################
# System Util Functions
###################################
NEPI_IP=192.168.179.103

# echo variable value
function echovar(){
    local var_name="$1"
    echo "$var_name: ${!var_name}"
}
export -f echovar

# ping internet
function pingi(){
    if ! ping -c 2 google.com; then
        echo "No Internet Connection"
        return 0
    else
        echo "Internet Connected"
        return 1
    fi
}
export -f pingi

# ping nepi
function pingn(){
  ping ${NEPI_IP}
}
export -f pingn

# source bashrc
function sbrc(){
    source /home/${USER}/.bashrc
}
export -f sbrc

function sdhcp(){
    sudo dhclient -r
    sudo dhclient
    sudo dhclient -nw
}
export -f sdhcp

function snvm(){
  echo ' ' | sudo tee -a $BASHRC
  echo '##### NVM Config #####' | sudo tee -a $BASHRC
  echo 'export NVM_DIR='/home/${NEPI_USER}'/.nvm' | sudo tee -a $BASHRC
  echo '[ -s ${NVM_DIR}/nvm.sh ] && \. ${NVM_DIR}/nvm.sh' | sudo tee -a $BASHRC
  echo '[ -s ${NVM_DIR}/bash_completion ] && \. ${NVM_DIR}/bash_completion' | sudo tee -a $BASHRC
}
export -f snvm

utilsn="${utilsn}
################################
### SYSTEM UTIL FUNCTIONS
################################
pingi = Check for internet
sbrc = Source the current users bashrc file
sdhcp = Start DHCP Internet Client
snvm = Sources NVM (Node Version Manager) nmv.sh"


###################################
# File Util Functions
###################################

# Function to search for text
# Example call: find 'nepi_sdk.parse_header_msg'
function ftext(){
grep -r "$@" ./*
}
export -f ftext

# Function to search for text
# Example call: find 'nepi_sdk.parse_header_msg'
function ffile(){
find ./* -iname  "*$@*" 
}
export -f ffile

function update_text_value(){
  KEY=$2
  UPDATE=$3
  FILE=$1
  if [ -f "$FILE" ]; then
    if grep -q "$KEY" "$FILE"; then
      sed -i "/^$KEY/c\\$UPDATE" "$FILE"
    else
      echo "$UPDATE" | sudo tee -a $FILE
    fi
  else
    echo "File not found ${FILE}"
  fi
}
export -f update_text_value


function update_yaml_value(){
    export UPDATE_YAML_KEY=$1
    #echo $UPDATE_YAML_KEY
    export UPDATE_YAML_VAL=$2
    #echo $UPDATE_YAML_VAL
    export UPDATE_YAML_FILE=$3
    #echo $UPDATE_YAML_FILE

    yq e -i '.'"$UPDATE_YAML_KEY"' = env(UPDATE_YAML_VAL)' $UPDATE_YAML_FILE
}
export -f update_yaml_value

function export_yaml_value(){
    KEY=$1
    #echo $KEY
    VARIABLE=$2
    #echo=$VARIABLE
    FILE=$3
    #echo=$FILE
    verbose=0
    value=$(yq e '.'"$KEY"'' $FILE)
    export ${VARIABLE}=$value
    #Secho "${VARIABLE}=${value}"
}
export -f export_yaml_value

function load_config_file(){
    config_file=$1
    echo $config_file
    if [ -f "$config_file" ]; then
        keys=($(yq e 'keys | .[]' ${config_file}))
        for key in "${keys[@]}"; do
            export_yaml_value "${key}" "${key}" "$config_file" 
        done
    else
        echo "Config file not found ${config_file}"
    fi
}

export -f load_config_file

function print_config_file(){
    echo $1
    config_file=$1
    if [ -f "$config_file" ]; then
        CONFIGN="#############################
        ## NEPI Config Settings ##
        #############################
        FILE=${config_file}"

        keys=($(yq e 'keys | .[]' ${config_file}))
        for key in "${keys[@]}"; do
            value=$(yq e '.'"$key"'' $config_file)
            echo "${key}=${value}"
            CONFIGN="${CONFIGN}
            ${key}=${!key}"
        done
        echo $CONFIG
    else
        echo "Config file not found ${config_file}"
    fi
}

export -f print_config_file


function path_backup(){
    source_path=$1
    #echo $source_path
    backup_path=${1}.bak
    if [[ -n "$2" ]]; then
      backup_path=$2
    fi  
    #echo $backup_path

    overwrite=0
    if [[ -n "$3" ]]; then
      overwrite=$3
    fi
    #echo $overwrite

    if [[ -d "$source_path" || -f "$source_path" ]]; then
        if [[ -d "$source_path" ]]; then
          if find "$source_path" -maxdepth 0 -empty | read; then
            echo "Source folder is empty, nothing to backup ${source_path}"
            return 3
          elif [[ ! -d "${backup_path}" ]]; then
              echo "Creating  ${source_path} path copy at ${backup_path}"
              sudo mkdir -p ${backup_path}
              sudo cp -R -a ${source_path} ${backup_path}
          elif [[ -d "${backup_path}" && "overwrite" -eq 1 ]]; then
              echo "Copying ${source_path} to ${backup_path}"
              sudo rm -r $backup_path
              sudo cp -R -a $source_path $backup_path
          fi
        elif [[ -f "$source_path" ]]; then
          if [ ! -f "${backup_path}" ]; then
              echo "Creating  ${source_path} path copy at ${backup_path}"
              sudo cp -R -a ${source_path} ${backup_path}
          elif [[ -f "${backup_path}"  && "overwrite" -eq 1 ]]; then
            echo "Copying ${source_path} to ${backup_path}"
            sudo rm -r ${backup_path}
            sudo cp -R -a ${source_path} ${backup_path}
          fi
    
        else
          echo "Failed to backup path ${backup_path}"
          return 2
        fi
    else
      echo "Failed to find source path ${source_path}"
      return 1
    fi
    if [[ -d "$backup_path" || -f "$backup_path" ]]; then
        echo "Created ${source_path} path copy at ${backup_path}"
    else
        echo "Failed to backup path ${backup_path}"
        return 1
    fi
}
export -f path_backup

function path_replace(){
    source_path=$1
    #echo $source_path
    backup_path=${1}.bak
    if [[ -n "$2" ]]; then
      backup_path=$2
    fi  
    #echo $backup_path

    overwrite=0
    if [[ -n "$3" ]]; then
      overwrite=$3
    fi
    #echo $overwrite

    if [[ -d "$source_path" || -f "$source_path" ]]; then
        if [[ -d "$source_path" ]]; then
          if find "$source_path" -maxdepth 0 -empty | read; then
            echo "Source folder is empty, nothing to backup ${source_path}"
            return 3
          elif [[ ! -d "${backup_path}" ]]; then
              echo "Creating  ${source_path} path copy at ${backup_path}"
              sudo mkdir -p ${backup_path}
              sudo cp -R -a ${source_path} ${backup_path}
          elif [[ -d "${backup_path}" && "overwrite" -eq 1 ]]; then
              echo "Copying ${source_path} to ${backup_path}"
              sudo rm -r $backup_path
              sudo cp -R -a $source_path $backup_path
          fi
        elif [[ -f "$source_path" ]]; then
          if [ ! -f "${backup_path}" ]; then
              echo "Creating  ${source_path} path copy at ${backup_path}"
              sudo cp -R -a ${source_path} ${backup_path}
          elif [[ -f "${backup_path}"  && "overwrite" -eq 1 ]]; then
            echo "Copying ${source_path} to ${backup_path}"
            sudo rm -r ${backup_path}
            sudo cp -R -a ${source_path} ${backup_path}
          fi
    
        else
          echo "Failed to backup path ${backup_path}"
          return 2
        fi
    else
      echo "Failed to find source path ${source_path}"
      return 1
    fi
    if [[ -d "$backup_path" || -f "$backup_path" ]]; then
        echo "Created ${source_path} path copy at ${backup_path}"
    else
        echo "Failed to backup path ${backup_path}"
        return 1
    fi
}
export -f path_replace


function path_sync(){
    source_path=$1
    target_path=$2
    delete=1
    if [[ -n "$3" ]]; then
    	delete=$3
    fi
    if [[ -d "$source_path" ]]; then
      if find "$source_folder" -maxdepth 0 -empty | read; then
          echo "Source folder is empty, nothing to sync ${source_folder}"
          return 3
      else
        if [[ ! -d "${target_path}" ]]; then
          echo "Creating target path ${target_path}"
          sudo mkdir -p ${target_path}
        fi
        if [[ -d "${target_path}" ]]; then
          echo "Syncing Folder ${source_path} to ${target_path}"
          if [[ "$delete" -eq 1 ]]; then
          	sudo rsync -avhr ${source_path}/* ${target_path}/ --delete
          else
          	sudo rsync -avhr ${source_path}/* ${target_path}/ --delete
          fi
        else
          echo "Failed to create target path ${target_path}"
          return 2
        fi
      fi
    elif [[ -f "$source_path" ]]; then
      echo "Syncing File ${source_path} to ${target_path}"
      sudo rsync -avhr ${source_path} ${target_path}
    elif [[ -L "$source_path" ]]; then
      echo "Syncing Symlink ${source_path} to ${target_path}"
      if [[ -d "${target_path}" ]]; then
          echo "Deleting existing target file ${target_path}"
          sudo rm ${target_path}
      fi
      echo "Copying Symlink ${source_path} to ${target_path}"
      sudo cp -a ${source_path} ${target_path}
    else
      echo "Failed to find source path ${source_path}"
      return 1
    fi
    echo echo "Sync complete ${source_path} to ${target_path}"
}
export -f path_sync

function path_delete(){
    source_path=$1
    if [[ -d "$source_path" || -f "$source_path" || -L "$source_path" ]]; then
          echo "Deleting path ${source_folder}"
          sudo rm -r $source_path
    else
      echo "Path not found: ${source_path}"
      return 1
    fi
}
export -f path_delete




function create_nepi_path_link(){
    path=$1
    if [[ -d "${path}" || -f "${path}" ]]; then
      echo "Copying path from ${path} to ${path}.nepi"
      if [[ -d "${path}.nepi" || -f "${path}.nepi" ]]; then
          sudo rm -r ${path}.nepi
      fi
      sudo cp -R -a ${path} ${path}.nepi
      if [[ -d "${path}.nepi" || -f "${path}.nepi" ]]; then
        echo "Deleting path ${path}"
        sudo rm -r ${path}
        echo "Linking ${path} to ${path}.nepi"
        sudo ln -sf ${path}.nepi ${path}
        fi
    else
      echo "Path not found: ${path}"
    fi
}
export -f create_nepi_path_link


#### Update Help Test
utilsn="${utilsn}
################################
### NEPI FILE UTIL FUNCTIONS
################################
ftext = Find text in files recursively
ffile = Find filenames with text match recursively
update_text_value = Adds or Replaces value in text file given FILE KEY UPDATE_STRING FILE
update_yaml_value = Update entry in yaml file given KEY VAL FILE
export_yaml_value = Exports the value of yaml entry to system variable given KEY VARIBLE FILE
load_config_file = Exports all of the yaml entries to system variables given FILE"



###################################
# Command Line Confi Util Functions
###################################

# user_color=01;32m
# if [[ "$USER" == "nepi" ]]; then
#   user_color=01;33m # Green
# elif [[ "$USER" == "nepi_admin" ]]; then
#   user_color=01;35m # Purple
# elif [[ "$USER" == "nepi_host" ]]; then
#   user_color=01;34m # Blue
# fi
# export USER_COLOR=$user_color


head_name=$(git rev-parse --abbrev-ref HEAD >/dev/null 2>&1)
if [ "$?" -eq 0 ]; then #$(is_git_repo $PWD) -eq 1 ]; then
  export PS1="\u@\h \[\e[32m\]\w \[\e[91m\]\$(parse_git_branch)\[\e[00m\]$ "

  #GIT Command Line Branch Display
  parse_git_branch() {
      git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
  }
fi

###################################
# Docker Util Functions
###################################

if which docker &> /dev/null; then
  function dimg(){
    sudo docker images
  }

  function dps(){
    sudo docker ps -a
  }

  
utilsn="${utilsn}
###########################
### Docker UTIL FUNCTIONS
###########################
dimg = sudo docker images
dps = sudo docker ps -a"

fi



###################################
# ROS Util Functions
###################################
NROS=/opt/nepi/nepi_engine/setup.bash
ROS=/opt/ros/noetic/setup.bash
HAS_ROS=$(dpkg -l | grep ros-)
if [ 1 ]; then # [[ -z "$HAS_ROS" ]]; then

    export NEEDS_ROS=1

    # Function to search for topic containing string
    function sros(){
      # Source ROS Env
      if [[ -f "$NROS" ]]; then
        source ${NROS}
      elif [[ -f "$ROS" ]]; then
        source ${ROS}
      else
        echo "No Ros Setup File Found"
      fi
      export NEEDS_ROS=0
    }

    export -f sros

    # Function to search for topic containing string
    function ftopic(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sros
      wait
    fi
    rostopic list | grep "$@" 
    }

    # Function to print all topics out
    function ltopics(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sleep 1 & sros
      wait
    fi
    rostopic list
    }

    # Function to listen to topic
    function etopic(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sleep 1 & sros
      wait
    fi
    rostopic echo "$@" 
    }

    # Function to search for service containing string
    function fservice(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sleep 1 & sros
      wait
    fi
    rosservice list | grep "$@" 
    }

    # Function to print all services out
    function lservices(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sleep 1 & sros
      wait
    fi
    rosservice list
    }

    # to call service
    function cservice(){
    if [ "$NEEDS_ROS" -eq 1 ]; then
      sleep 1 & sros
      wait
    fi
    rosservice call "$@"
    }

utilsn="${utilsn}
###########################
### ROS UTIL FUNCTIONS
###########################
sros = source ros bash setup
snros = source nepi ros bash setup
ltopics = List all active topics
ftopic = Find topics containing provided string
etopic = Echo to provided topic
lservices = List all active services
fservice = Find services containing provided string
cservice = Call service"

fi


export UTILSN=${utilsn}

export NEPI_UTILS_SOURCED=1


